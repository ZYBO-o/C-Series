- 标准库未给容器添加大量功能，而是提供一组独立于容器的`泛型算法`：
  - `算法`：它们实现了一些经典算法的公共接口
  - `泛型`：它们可用于不同类型的容器和不同类型的元素
- 利用这些算法可实现容器基本操作很难做到的事，例如查找/替换/删除特定值、重排顺序等

## 一.概述

- 大多数算法定义在`algorithm`头文件中，另外一组数值算法定义在`numeric`头文件中

- 标准库算法不直接操作容器，而是遍历迭代器范围

- 指针就像内置数组上的迭代器，故泛型算法也可操作内置数组和指针

- `find`算法：

  - 作用：将范围中每一个元素与给定值比较，返回第一个等于给定值的元素的迭代器，如果没有匹配则返回该范围的尾后迭代器。
  - 用法：有3个参数，前2个是输入范围，第3个是给定值。
  - 实现：调用给定值类型的`==`算符来比较。

  ```c++
  
  ```

- 算法只依赖迭代器来访问元素并在范围中推进，不依赖于容器操作。但迭代器依赖元素类型上定义的算符，如`==`、`<`等

- 算法不会改变容器大小。它可能改变元素值或移动元素，但不会添加或删除。

- 标准库定义了`插入迭代器`，给它们赋值时会在容器上插入。算法操作这样的迭代器时可完成插入元素的效果。

- 一些算法提供了接口，允许使用自定义的`谓词`来代替默认算符

- `count` 算法：

  - 作用：将范围中每一个元素与给定值比较，返回给定值在范围中出现的次数。
  - 用法：有3个参数，前2个是输入范围，第3个是给定值。
  - 实现：调用给定值类型的`==`算符来比较。

## 二.初试泛型算法

- 附录A中列出所有算法
- `输入范围`：大多标准库算法都对一个范围内的元素操作，这个范围称为输入范围。接受输入范围的算法总是用前两个参数来表示输入范围。
- 多数算法遍历输入范围的方式相似，但使用元素的方法不同（是否读，是否写，是否重排等）。

### 1.只读算法

- `只读算法`只读取输入范围的元素，不改变它们。如上一节的find和count

- 使用只读算法，最好用cbegin/cend

- `accumulate`算法（定义于numeric）：

  - 作用：对范围中元素求和，再加上给定值，返回求值结果。
  - 用法：有3个参数，前2个是输入范围，第3个是给定值。
  - 实现：调用给定值类型的`+`算符来求和。

- 例子：算法严格使用给定值的操作符

  ```c++
  vector<string> v={"hello","world"};
  string sum=accumulate(v.cbegin(),v.cend(),"");          //错，const char *类型未定义+算符
  string sum=accumulate(v.cbegin(),v.cend(),string(""));  //对，string上定义了+算符
  ```

- 

- `equal`算法：

  - 作用：确定两序列的值是否相同。所有元素都相等时返回true，否则false
  - 用法：有3个参数，前2个是第一个序列的输入范围，第3个是第二个范围的首迭代器。
  - 实现：调用`==`算符来比较，元素类型不必严格一致。

  > string类重载了==，可以比较两个字符串是否长度相等且元素对位相等。
  >
  > c风格字符串本质是char* 类型，用==比较两个char* 对象，只是检查两个指针值是否相等，即地址是否相等。

- 某些算法接受单一迭代器来指定第二个序列，这些算法都假定第二个序列至少和第一个序列一样长

### 二.写容器元素的算法 

- 可对序列中元素重新赋值，要求原序列大小不小于要写入的元素数目。算法不执行容器操作，故不可改变序列大小

- `fill`算法：

  - 作用：用给定值填满输入范围
  - 用法：有3个参数，前2个是输入范围，第3个是给定值。

- 操作两序列的算法不要求两序列的容器相同，但要求元素可操作

- 操作两序列的算法分为两种：

  - 接受3个迭代器，前两个表示第一个序列的范围，第三个表示第二个序列的起始。总是假定第二个序列至少和第一个序列一样长
  - 接受4个迭代器，前两个表示第一个序列的范围，后两个表示第二个序列的范围

- `fill_n`算法：

  - 作用：用给定值填满长为n的区间
  - 用法：有3个参数，第1个代表序列起始的迭代器，第2个是序列长度的计数值，第3个是填入的给定值。

- fill_n假定长为n的空间总是有效的，类似指针运算。算法不会改变容器的大小。

  > 不能在空容器上调用fill_n，或者类似的写元素的算法，因为是空的，这条语句的结果是未定义的。

- `插入迭代器`：给插入迭代器赋值会向容器中插入元素，即真正改变容器的大小。

- 通过给插入迭代器赋值，算法可保证容器中总有足够的空间

- `back_inserter`函数定义于`iterator`头文件中，它接受一个指向容器的引用，返回该容器的一个插入迭代器。通过此迭代器赋值时，赋值符会调用容器类型的`push_back`来添加元素

- 例子：算法中使用back_inserter

  ```c++
  vector<int> vec;                    //空vector
  //fill_n(vec.begin(),10,0);           //错，算法不可向空vector写值
      
  cout<< "size is : " << vec.size() << endl;
  fill_n(back_inserter(vec),10,0);    //对，在vec尾部插入10个0
  
  for (auto i : vec) 
      cout << i << " " ;
  cout << endl;
  cout<< "size is : " << vec.size() << endl;
  
  //=======================输出=========================
  //	size is : 0
  //	0 0 0 0 0 0 0 0 0 0 
  //	size is : 10
  ```

- `copy`算法：

  - 作用：将输入范围的值拷贝到目标序列，返回目标序列的尾后迭代器
  - 用法：有3个参数，前2个是输入范围，第3个是目标序列的起始位置

- 很多算法提供`copy版本`，即计算新元素的值后，不放入原来的序列，而是放入一个新序列中。

- `replace`算法：

  - 作用：将序列中所有等于给定值的元素换为另一个值
  - 用法：有4个参数，前2个是输入范围，后2个分别是要搜索的值和新值

- `replace_copy`算法：

  - 作用：将序列中所有等于给定值的元素换为另一个值，放入新序列，原序列不变。
  - 用法：有5个参数，前2个是输入范围，第3个是输出序列的首迭代器，最后2个分别是要搜索的值和新值

- 例子：replace和replace_copy

  ```c++
  list<int> ilst={0,1,2,3,4};
  vector<int> ivec;
  //原址版本，将ilst中的0都替换为42
  replace(ilst.begin(),ilst.end(),0,42);                              
  for (auto i : ilst)
      cout << i << " " ;
  cout<< endl;
  //copy版本，将ilst中的0替换为42后插入ivec，ilst不变
  replace_copy(ilst.cbegin(),ilst.cend(),back_inserter(ivec),42,1);   
  for (auto i : ilst)
      cout << i << " " ;
  cout<< endl;
  for (auto i : ivec)
      cout << i << " " ;
  
  //输出：
  // 42 1 2 3 4 
  // 42 1 2 3 4 
  // 1 1 2 3 4 
  ```

### 3.重排容器元素的算法

- 可对容器中元素重新排列顺序

- `sort`算法：

  - 作用：重排输入序列的元素使其有序
  - 用法：有2个参数，是输入范围
  - 实现：调用序列元素类型的`<`算符

- `unique`算法：

  - 作用：重排输入序列，消除相邻重复项。返回消除后的无相邻重复值的范围的尾后迭代器
  - 用法：有2个参数，是输入范围

- unique不真正删除元素，只是将后面的不重复值前移来覆盖前面的重复值，使不重复值在序列前部。

- unique将不重复元素向首部集中，尾部（返回迭代器之后）的元素值是未定义

- 真正删除元素需要使用容器操作

- 例子：消除重复单词

  ```c++
  //将输入vector中的string元素重排并消除重复
  void elimDups(vector<string> &words){
      sort(words.begin(),words.end());                    //将元素排序，使重复项相邻
      auto end_unique=unique(words.begin(),words.end());  //将不重复元素集中到序列前端，返回不重复元素序列的尾后迭代器
      words.erase(end_unique,words.end());                //擦除不重复序列之后的元素
  }
  ```

## 三.定制操作

- 对于使用元素的`==`、`<`等算符的算法，标准库允许在执行算法时用自定义操作代替默认算符，而不需要在类型中重载。

### 1.向算法传递参数



