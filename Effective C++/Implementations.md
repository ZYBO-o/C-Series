## 实现

<!-- GFM-TOC -->

* [26.尽可能延后变量定义式的出现时间](#26尽可能延后变量定义式的出现时间)
* [27.尽量少做转型动作](#27尽量少做转型动作)
* [28.避免返回handles指向对象内部成分](#28避免返回handles指向对象内部成分)
* [29.为"异常安全"而努力是值得的](#29为异常安全而努力是值得的)
* [30.透彻了解inlining的里里外外](#30透彻了解inlining的里里外外)
* [31.将文件间的编译依存关系降至最低](#31将文件间的编译依存关系降至最低)

<!-- GFM-TOC -->

---

> 大多数情况下，适当提出class与function声明，是最花费心里的两件事，一旦完成，相应的实现大多直接了当。尽管如此，还是有些东西需要小心。
>
> + 太快定义变量可能造成效率上的拖延。
> + 过度使用转型可能导致代码变慢又难维护，又招来微妙难解的错误
> + 返回对象"内部数据之号码牌(handles)"可能造成破坏封装并留给客户虚吊号码牌(dangling handls)
> + 未考虑异常带来的冲击则可能导致资源泄露和数据败坏
> + 过度热心地inlining可能引起代码膨胀
> + 过度耦合(coupling)则可能导致让人不满意的冗长建置时间(build times)
>
> 下面的六则条款是对应的解决方案

---

### 26.尽可能延后变量定义式的出现时间

+ **尽可能延后变量定义式的出现，这样做可增加程序的清晰度并改善程序效率。**

这个条款从字面意思还是很好理解的，就是在使用这个变量前才去定义，而不是很早就定义了它，而在很后面的时候才去使用。这个条款只适用于对变量声明位置没有要求的语言，比如C++。对于像C或者一些脚本语言，语法要求变量声明放在函数开始处，这个条款就不能使用了。

但其实从使用的角度而言，如果不是语法的硬性要求，还是在变量使用前再去定义变量的做法比较好。这有几点原因:

+ 最直观的就是可读性比较好，程序员在阅读代码时，看到一个陌生的变量名，不用向上翻好几页才看到它的定义类型，而且对于开发者而言，也不会出现前面定义了一个变量，之后又忘记使用它的情况。
+ 可以节省资源

考虑以下的代码：

```c++
void example(const A& parm)
{
    A a;
    fun(); // 这个fun()函数不会使用a
    a = parm;
    …
}
```

假设存在一个类A，如果在程序的开始处就定义它的对象a（调用了构造函数），中间夹了一个函数fun()， **这个函数可能抛出异常，导致下面的程序不去执行，这样对象a的构造函数就白调用了，既浪费了空间，也浪费了时间。**

所以改进的做法就是：

```c++
void example(const A& parm)
{
    fun();
    A a;
    a = parm;
    …
}
```

这下如果fun()抛出异常，那么也不会浪费资源了，但这里还是有一个比较“废”的地方， **就是调用了构造函数，也调用了赋值运算，但这两个操作的目的都是给a一个值，所以可以将这两个操作进行精减，直接调用A的拷贝构造函数** ，像这样：

```c++
void example(const A& parm)
{
    fun();
    A a(parm);
    …
}
```

赋值运算就不用调用了。
书上还讲到了一个写代码常见的问题，就是循环中的变量定义，是放在循环内比较好呢，还是放在循环外比较好呢？看下面的例子：

```c++
// 放在循环外
A a;
for(int i = 0; i < N; ++i)
{
    a = a * b[i];
    …
}
//后面不再使用a
```

```c++
// 放在循环内
for(int i = 0; i < N; ++i)
{
    A a(b[i]);
    …
}
//后面不再使用a
```

分析一下:

+ **如果采用放在循环外的方法，代价是1次构造+1次析构+N次赋值；**
+ **如果采用放在循环内的方法，代价是N次构造+N次析构。**

所以究竟哪个更好，还是要看构造函数、析构函数VS赋值操作，哪一个比较废。 **<font color = red>但如果两方的代价差不多，还是推荐放在循环内的做法，因为这种做法使得a的作用域局限于for循环内，符合作用域能小就小的编程原则。</font>**



---

### 27.尽量少做转型动作

+ **如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。**

+ **如果转型是必要的，试着将它隐藏于某个函数背后，客户可以随后调用这个函数，而不需要将转型放在他们自己的代码里。**

+ **宁可使用C++风格的新式转型，少用C风格转型，因为前者很容易辨识出来，而且也比较有着分门别类的职掌。**

转型可以按风格可以分成C风格转型和C++风格转型两大类，C风格转型很容易看到，因为我们会经常使用，像

```c++
(T) expression
```

以及：

```c++
T (expression)
```

最经典的例子就是处理整数除法，在C/C++程序中，整数除法的结果还是整数，有时会得不到我们想到的结果，比如3/5，结果是0，而不是0.6，但如果这样`double(3) / 5`，结果就会是0.6了，因为转型操作`double(3)`，将整数转成了浮点数，这样就是小数除法了，可以得到带小数点的结果。

C++风格的转型操作分成四类：

```c++
const_cast<T>(expression)
static_cast<T>(expression)
dynamic_cast<T>(expression)
reinterpret_cast<T>(expression)
```

**effective推荐使用的是前三种，最后一种是把一个指针转成整数或者把整数看成指针，对平台依赖性很强，不建议使用。**

#### const_cast

`const_cast`很简单，就是去掉常量属性，比如：

```c++
int main()
 {
     int a= 3;
    const int* ca = &a;
     int *pb = const_cast<int*> (ca);
     *pb = 5;
     cout << a << endl; // a的输出结果是5
 }
```

但这种 **<font color = red>常量性的转换只是针对于指针或引用（包括this指针），是不能针对于普通变量的</font>** ，比如下面的做法就是错误的：

```c++
 int main()
 {
     const int a = 3;
     int b = const_cast<int>(a);  //编译出错，只能使用static_cast或者C风格转换
 }
```

对于`const_cast`，既可以将`const->非const`，也可以将`非const->const`，只要记住两点:

**其一，这个操作只对指针或引用有效**

**其二，<font color = red>这个操作并不改变被转换对象的常属性</font>**

```c++
 int a= 3;
 const int* ca = &a;
 int *pb = const_cast<int*> (ca);
 //ca仍是指向常量的指针，对它的操作，比如*ca = 5，是会报编译错的。
```

#### static_cast

`static_cast`是最为常用C++转型了，我们常见的`int->double`亦或是`float->int`等等，都是用`static_cast`来进行转换的（包括`const int -> int`，以及`int -> const int`， **只要不是常指针/引用->non常指针/引用** ）。

#### dynamic_cast

`dynamic_cast`是当想把基类指针转成派生类指针时用，这种转换可以保证安全性，当把两个不相干的类之间用`dynamic_cast`时，转换的结果将是空指针，同时若基类指针指向的对象只是基类本身时，对基类指针进行`dynamic_cast`向下转型到派生类，会得到空指针，防止进一步的操作。

介绍到这里，需要我们回答一个问题，既然旧式转型已经够用了（毕竟C语言就是这样用的，没有人抱怨转型的功能不够丰富），那为什么C++还要再定义功能重复的转型呢？

原因有两个：

+ **第一，细化转型使它们很容易在代码中被辨识出来，可以不去看上下文就知道这样的转型是什么类型的（常量转型还是向下转型）**
+ **第二，各转型动作的目标愈窄化，编译器愈可能诊断出错误的应用**

下面来讲一下，为什么effective中要我们尽量少做转型动作。

不清楚原理的转型会带来严重的bug，比如书上提到的，假设有一个基类Window，它有一个派生类SpecialWindow，它们都有一个`OnResize()`的成员函数，在派生类的`OnResize()`中想要先调用基类的`OnResize()`，于是有程序员便这样做了：

```c++
void SpecialWindow::OnResize()
{
	static_cast(*this).OnResize();
	…
}
```

这样真的没有问题吗？将派生类对象转成Window对象，然后对其调用OnResize()，这确确实实调用的是基类的OnResize()，但OnReszie()对成员变量操作的结果是你想要的吗？

答案是否定的， **因为static_cast生成的是一个临时的基类的对象，这个对象并不是真正组成派生类的那个基类，而是它的一个副本（<font color = red>这个副本的成员变量值与派生类对象中基类的成分是一样的，但地址不同</font>），调用OnResize()变更的结果是这个副本的成员变量变了，但派生类中包含的基类的成员变量却是没有任何变化的。** 好了，这就是bug了，在之后的测试中这个问题会让程序员纠结好一阵子。

一句话，转型生成的是一个copy，一份副本，有的时候这并不是你想要的，修正方法其实很简单，就是：

```c++
void SpecialWindow::OnResize()
{
	Window::OnResize(); // OK了，就这么简单
	…
}
```

有的转型操作也是比较废的，比如`dynamic_cast`，这个转型会对类名称进行strcmp，以判断向下转型是否合理， **如果继承深度比较大，那么每一次的`dynamic_cast`将会进行多次strcmp，这将严重影响程序的执行效率。** 解决方法就是如果可以话，直接使用指向子类的指针，真的想用父类的指针（比如工厂设计模式等），那就考虑多态吧，在父类相应的函数前面加virtual，然后子类进行覆盖即可。

最后总结一下，有的程序员认为，转型其实什么也没有做，只是告诉编译器把某种类型视为另一种类型而已。如果说的是指针，这样理解是正确的，但如果说的是全部的话（包括变量），恐怕就不妥了，比如`static_cast(a) / b`，这一类经典的整数除法->小数除法转换，转换前后在底层产生的代码是绝对不同的。


---

### 28.避免返回handles指向对象内部成分

+ **避免返回`handles`（包括reference、指针、迭代器）指向对象内部，遵守这个条款可增加封装性，并将发生`dangling handles`的可能性降至最低。如果有必要必须要返回`handles`，在编写代码时就一定要注意对象和传出`handle`的生命周期。**

```c++
class Student
{
private:
    int ID;
    string name;
public:
    string& GetName()
    {
        return name;
    }
};
```

这是一个学生的类，类里面有两个成员变量，一个是学生ID，用整数表示，另一个是姓名，用string表示。有一个公有的方法`GetName()`，获得学生的名字，根据条款20所说的，使用引用可以防止资源不必要地拷贝，那么在返回值这边就用string&。但现在问题来了， **这个函数只是想返回学生的姓名，并不想用户对之进行修改，但返回引用却提供了这样的一个接口** ，如：

```c++
int main()
{
    Student s;
    s.GetName() = "Jerry";
    cout << s.GetName() << endl;
}
```

就可以把名字进行修改。你也许想到了，如果在前面加上const，像这样：

```c++
const string& GetName()
 {
     return name;
 }
```

就可以阻止`s.GetName() = “Jerry”`这样的代码了。

但这样写还是存在问题，就是 **<font color = red>如果返回的引用生命周期比对象本身要长时，引用就会悬空，它会指向一个不存在的string。</font>** 下面看一下“返回的引用生命周期比对象本身要长”的情况，这种情况还是很容易举出例子的，比如：

```c++
const string& fun()
{
    return Student().GetName();
}

int main()
{
    string name = fun(); //name指向一个不存的对象的成员变量
}
```

这时候即使name读取不报错，也是一个巨大的隐患，因为它已经是 **虚吊(dangling)** 的了。

**这就是为什么函数如果“返回一个handle代表对象内部成分”总是危险的原因，不在于返回值是不是const，而是<font color = red>在于如果handle（指针或引用）传出去了，就会暴露在“handle比其所指对象更长寿”的风险下。</font>**

但有些情况还是需要返回handle的，比如string或者vector里面的operator[]，就是返回的引用，因为需要对这里面的元素进行操作。



---

### 29.为"异常安全"而努力是值得的



---

### 30.透彻了解inlining的里里外外

+ **将大多数inlining限制在小型、被频繁调用的函数身上**

+ **不要只因为function templates出现在头文件，就将它们声明为inline**

`inline`是内联的关键字，它可以建议编译器将函数的每一个调用都用函数本体替换。这是一种以空间换时间的做法。把每一次调用都用本体替换，无疑会使代码膨胀，但可以节省函数调用的成本，因为函数调用需要将之前的参数以堆栈的形式保存起来，调用结束后又要从堆栈中恢复那些参数。

但注意`inline`只是对编译器的一个建议，编译器并不表示一定会采纳，比如当一个函数内部包含对自身的递归调用时，`inline`就会被编译器所忽略。对于虚函数的`inline`，编译器也会将之忽略掉，因为内联（代码展开）发生在编译期，而虚函数的行为是在运行期决定的，所以编译器忽略掉对虚函数的`inline`。对于函数指针，当一个函数指针指向一个`inline`函数的时候，通过函数指针的调用也有可能不会被编译器处理成内联。

```c++
inline void f() {...}	//假设编译器有意愿inline"对f的调用"
void (*pf) () = f;		//pf指向f
...
f();									//这个调用将被inline，因为它是一个正常调用
pf();									//这个调用不许不被inline，因为它是通过函数指针达成。
```

另一方面，即使有些函数没有inline关键字，编译器也会将之内联，用本体替换调用代码，比如直接写在class内部的成员函数，如下：

```c++
class Person
{
private:
    int age;
public:
    int getAge() const
    {
        return age;
    }
    void setAge(const int o_age);
};
void Person::setAge(const int o_age)
{
    age = o_age;
}
```

> 这里getAge()尽管没有inline关键字，但因为是直接写在class里面的，所以编译器将之处理成内联的；setAge()是在类内声明、类外定义的，编译器就不会将之处理成内联的了。

构造函数和析构函数虽然“看”似简单， **但编译器会在背后做很多事情，比如一个空的构造函数里面会由编译器写上对所有成员函数的初始化，如果将之inline，将会导致大批量的代码复制，所以不对构造函数和析构函数inline为好。**

要慎用inline，是因为一旦编译器真的将之inline了，那么这个inline函数一旦被修改，整个程序都需要重新编译，而如果这个函数不是inline的，那么只要重新连接就好。另外，一些调试器对inline函数的支持也是有限的。

作者认为，“一开始先不要将任何函数声明为inline”，经测试，确实发现某个函数的inline要比不对之inline的性能提升很多，才对之inline。在大多数情况下，inline并不是程序的瓶颈，真正的精力应该放在改善一些算法的修缮，以及反复调用的代码研究上，它们往往才是耗时的瓶颈所在。

---

### 31.将文件间的编译依存关系降至最低



---



