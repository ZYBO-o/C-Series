- 定义一个类时，可显式或隐式的指定在此类型对象上`拷贝`、`移动`、`赋值`、`销毁`时做什么。通过5种`成员函数`实现`拷贝控制`操作：
  - `拷贝构造函数`：用同类型的另一个对象初始化本对象时做什么（拷贝初始化）
  - `拷贝赋值算符`：将同类型的另一个对象赋值给本对象时做什么（拷贝赋值）
  - `移动构造函数`：用同类型的另一个对象初始化本对象时做什么（移动初始化）
  - `移动赋值算符`：将同类型的另一个对象赋值给本对象时做什么（移动赋值）
  - `析构函数`：本对象销毁时做什么（析构）
- 如果类未定义这些拷贝控制成员，编译器会自动合成一部分缺失的操作，因此很多类不需要自定义拷贝控制。最困难的经常是认识到什么时候需要自定义拷贝控制：编译器合成版本的行为可能并非预期。

## 一.拷贝，赋值与销毁

### 1.拷贝构造函数

- `拷贝构造函数`：这种构造函数的第一个参数是`自身类类型的引用`，且任何额外参数都有默认值。

- 拷贝构造函数的第一个参数必须是引用类型（否则传参时需要拷贝，循环调用）。虽然也可定义为非const，但几乎总是用`const引用`（不会改变被拷贝对象，且const引用能接受更多类型的参数）。

  ```c++
  class Foo{
    public:
    Foo();							//默认构造函数
    Foo(const Foo&);		//拷贝构造函数
    //...
  }
  ```

- **拷贝构造函数经常会被隐式使用（例如函数的传参和返回值），故不应该是`explicit`**

- 若未自定义拷贝构造函数，即使定义了其他构造函数， **<font color = red>编译器也会合成一个拷贝构造函数（这一点与默认构造函数不同）</font>**

- `合成的拷贝构造函数`若非删除，则会将其参数的非static成员逐个拷贝到正在构造的对象中：

  - 内置类型：直接拷贝
  - 类类型：用拷贝构造函数来拷贝
  - 数组：逐元素拷贝（若元素是类类型，也用拷贝构造函数）

- 例子：合成的拷贝构造函数

  ```c++
  class Sales_data{
  public:
      //拷贝构造函数，参数是该类类型的引用，经常是const引用
      Sales_data(const Sales_data &);
  private:
      string bookNo;
      int units_sold=0;
      double revenue=0.0;
  };
  //与合成的拷贝构造函数等价，逐个拷贝成员
  Sales_data::Sales_data(const Sales_data &orig):
                        bookNo(orig.bookNo),
                        units_sold(orig.units_sold),
                        revenue(orig.revenue)
                        {}
  ```

- 直接初始化和拷贝初始化的差别：

  - `直接初始化`：要求编译器使用普通函数匹配来选择最匹配的构造函数
  - `拷贝初始化`：要求编译器将`=`右侧运算对象拷贝到正在创建的对象中，需要时可进行隐式转换

  ```c++
  string dots(10,'.');                //直接初始化
  string s(dots);                     //直接初始化
  string s2=dots;                     //拷贝初始化
  string null_book="9-999-99999-9";   //拷贝初始化，发生C风格字符串到const string的隐式转换（临时量）
  string nines=string(100,'9');       //拷贝初始化
  ```

  > 拷贝初始化通常使用拷贝构造函数来完成，但当有一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。

- 拷贝初始化的工具：

  - `拷贝构造函数`：通常使用拷贝构造函数
  - `移动构造函数`：如果该类有移动构造函数且用`右值`调用时

- 拷贝初始化发生的情况:

  - 用`=`定义变量
  - 将对象作为 **实参传递给非引用类型的形参**
  - 从 **返回类型非引用的函数返回对象**
  - 用 **花括号列表初始化一个数组的元素或一个聚合类的成员**
  - 某些类类型会对其分配的对象使用拷贝初始化。例如初始化标准库容器或是调用`insert`/`push`时容器对元素进行拷贝初始化，而用`emplace`是对元素直接初始化

- 使用explicit的构造函数时，只能直接构造，不能拷贝构造（即，explicit的构造函数不可用于拷贝构造）

- 传递实参或返回值时，不能隐式使用explicit构造函数，必须显式使用

- 例子：explicit的构造函数不可用于拷贝构造

  ```c++
  vector<int> v1(10);     //对，直接初始化
  vector<int> v2=10;      //错，vector的接受大小的构造函数是explicit
  void f(vector<int>);    //f的参数非引用，需拷贝初始化
  f(10);                  //错，int不可拷贝为vector
  f(vector<int>(10));     //对，从int直接构造临时vector
  ```

- 拷贝初始化时，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。但即使编译器跳过拷贝/移动构造函数，他们仍必须是存在且可访问的（例如不能是private）

- 例子：跳过拷贝/移动构造函数，直接创建

  ```c++
  //编译器允许将上一行代码改写为下面一行，直接构造。
  string null_book="9-999-99999-9";   //拷贝初始化
  string null_book("9-999-99999-9");  //跳过拷贝构造函数，直接构造
  ```



### 2.拷贝赋值运算符

- 类可通过拷贝构造函数来控制初始化，也可通过`拷贝赋值算符`来控制对象赋值

- `重载算符`本质上是函数，其名字是`operator`关键字后接要定义的算符的符号。

- 赋值算符是名为`operator=`的函数，它也有返回类型和参数列表

- 某些算符，包括赋值算符，必须定义为成员函数。若算符是成员函数，则其`左侧对象`隐式绑定到this指针。对于二元算符，例如赋值算符，其`右侧对象`作为显式参数传递。

- 拷贝赋值算符接受一个与其所在类型相同的参数，返回左侧运算对象的引用（为与内置类型的赋值保持一致）。

- 标准库通常要求容器元素的类型有赋值算符，且返回值是左侧对象的引用，因为很多操作会拷贝元素。

- 若未自定义拷贝赋值算符，编译器会合成一个

- `合成的拷贝赋值算符`若非删除，则会将右侧对象的每个非static成员赋予左侧对象的对应成员（类类型成员调用拷贝赋值算符，数组成员逐个赋值）。它返回一个指向左侧对象的引用

- 例子：合成拷贝赋值算符

  ```c++
  class Sales_data{
  public:
      //拷贝赋值算符，参数是该类类型的引用，经常是const引用，返回该类类型的引用
      Sales_data &Sales_data::operator=(const Sales_data &);
  private:
      string bookNo;
      int units_sold=0;
      double revenue=0.0;
  };
  //左侧对象隐式绑定到返回的this，引用类型。右侧对象是传入参数，常量引用类型
  Sales_data &Sales_data::operator=(const Sales_data &rhs){
      bookNo=rhs.bookNo;
      units_sold=rhs.units_sold;
      revenue=rhs.revenue;
      return *this;
  }
  ```



### 3.析构函数

- 析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员并执行函数体，析构函数执行函数体并销毁对象的非static数据成员

- `析构函数`的名字是波浪线`~`后接类名，它没有返回值也不接受参数，故不可重载，一个类只能有一个析构函数

- 构造函数和析构函数的共性和差异：

  - 构造函数有一个显式的初值列表和一个函数体；析构函数有一个函数体和一个隐式的析构部分。
  - 构造函数先做成员初始化再执行函数体，成员按照类中出现的顺序初始化；析构函数先执行函数体再销毁成员，成员按照初始化的逆序销毁。

- 析构函数的析构部分是隐式的，成员如何销毁完全取决于类型：类类型成员析构时调用析构函数，内置成员析构时什么都不做，特别是，析构内置指针成员不会delete它指向的对象。

- 对象被销毁时调用析构函数：

  - 变量离开作用域被销毁
  - 类对象被销毁时成员被销毁
  - 标准库容器/数组被销毁时，元素被销毁
  - 动态对象的指针被delete时对象被销毁
  - 临时对象，创建它的完整表达式结束时被销毁

- 析构函数自动运行，故程序可按需分配资源，无需担心何时释放（前提是析构函数良好定义）

- 例子：析构函数自动运行

  ```c++
  {//进入新作用域
      Sales_data *p=new Sales_data;       //内置指针
      auto p2=make_shared<Sales_data>();  //智能指针
      Sales_data item(*p);                //拷贝构造对象
      vector<Sales_data> vec;
      vec.push_back(*p2);                 //拷贝进容器
      delete p;                           //管理动态对象的内置指针需手动delete
  }
  //离开作用域，p2、item、vec的析构函数自动运行
  //销毁p2会递减其引用计数，计数为0时对象被释放
  //销毁vec时其元素也被销毁
  ```

- 若未自定义析构函数，编译器会合成一个
- `合成析构函数`若非删除，则其函数体为空，只有隐式的析构部分。
- 析构函数体并不直接销毁成员，成员是在析构函数体执行之后的隐式析构阶段被销毁。



### 4.三/五法则

- 三个基本操作可控制类的拷贝：`拷贝构造函数`、`拷贝赋值算符`、`析构函数`。C++11中还定义了`移动构造函数`和`移动赋值算符`

- 这5个操作不必全部定义，可以只定义一两个。但这些操作经常是一个整体，需要同时定义。

- `需要自定义析构函数的类也需要自定义拷贝和赋值`

- 若一个类需要自定义析构函数（如管理动态对象），几乎肯定它也需要自定义拷贝和赋值操作

- 例子：需要析构函数时使用默认的拷贝和赋值（反例）

  ```c++
  lass HasPtr{
  public:
      //构造对象时产生动态对象，其指针作为成员
      HasPtr(const string &s=string()) : ps(new string(s)),i(0) {}
    
      //自定义了析构函数来处理动态对象，但未自定义拷贝和赋值。故该类对象的所有拷贝共享动态对象
      ~HasPtr(){delete ps;}
  private:
      string *ps;
      int i;
  };
  //定义函数处理该类对象
  HasPtr f(HasPtr hp){    //调用函数时传入指针被拷贝给形参hp，实参和hp共享底层对象
      HasPtr ret=hp;      //拷贝，默认拷贝操作只拷贝指针，使ret和hp共享底层对象
      return ret;         //将拷贝返回
  }                       //问题1、离开函数作用域时形参hp被销毁，调用析构函数将底层对象释放，实参和ret内的指针都空悬
                          //问题2、返回类型非引用，故ret传出时拷贝，ret也被销毁，同一底层对象释放两次
  HasPtr p("some values");
  f(p);                   //调用后，p中的指针空悬，且p底层的对象被释放两次
  HasPtr q(p);            //p和q的指针都空悬
  
  ```

- `需要自定义拷贝操作的类也需要自定义赋值操作，反之亦然`

- 需要自定义拷贝和赋值时，不一定需要自定义析构函数。例如，为类的每个对象生成编号

#### 习题尝试

+ 13.15

```c++
#include<iostream>
using namespace std;
class numbered
{
private:
    static int seq;
public:
    numbered() {mysn = ++seq;}
    //13.15
    numbered(numbered &n) {mysn = ++seq;}
    int mysn;
};
int numbered::seq = 0;
void f(const numbered &s)
{
    cout << s.mysn << endl;
}
int main(){
    numbered a, b = a, c = b;
    f(a);
    f(b);
    f(c);
    return 0;
}
```



### 5.使用=default

- 将拷贝控制成员定义为`=default`可显式要求编译器生成合成的版本。只能对具有合成版本的成员函数使用（构造函数和拷贝控制成员）

- 例子：使用=default

  ```c++
  class Sales_data{
  public:
      Sales_data()=default;
      Sales_data(const Sales_data &)=default;
      Sales_data &operator=(const Sales_data &);
      ~Sales_data()=default;
  };
  //=default可在类内定义也可在类外定义
  Sales_data &Sales_data::operator=(const Sales_data &)=default;
  ```

  > 在类内用`=default`修饰成员的声明时，合成的函数将隐式地声明为内联的；不希望合成的成员时内联函数，应该只对成员的类定义使用`=default`。



### 6.阻止拷贝

- 大多数类应该定义默认构造函数、拷贝构造函数、拷贝赋值算符，无论显式还是隐式。但对某些类，这些操作并无意义。例如iostream不可拷贝。
- 若要阻止一个操作（例如禁止拷贝），不定义是无效的，因为编译器会合成。正确做法是将其定义为删除函数
- `删除函数`是这样一种函数：虽然定义了，但不可以任何形式使用。C++11可将拷贝构造函数和拷贝赋值算符定义为删除来阻止拷贝。
- 定义删除函数的方法是在参数列表后将其定义为`=delete`，它通知编译器，我们不希望定义这些成员。
- `=delete`和`=default`的区别：
  - =delete必须出现在第一次声明时，而=default只需在定义时给出。因为编译器在函数声明时就必须知道它是否为删除的，以便禁止使用它
  - =delete可对任意函数使用，而=default只能对编译器能合成的函数使用
- 不能删除析构函数。若删除析构函数则无法销毁此类型对象。

- 删除析构函数的情形：

  - 对于删除了析构函数的类，编译器不允许对该类型定义变量/临时对象
  - 若类的类类型成员删除了析构函数，则该类也不能定义变量/临时对象。
  - 对于删除了析构函数的类，可以分配该类型的动态对象，只是不能释放

- 例子：删除析构函数的类可分配动态对象

  ```c++
  struct NoDtor{
  public:
      NoDtor()=default;
      ~NoDtor()=delete;   //删除析构函数
  };
  NoDtor nd;              //错，不可创建变量
  NoDtor *p=new NoDtor(); //对，可分配动态对象但不可释放
  delete p;               //错，析构函数是删除的
  ```

对某些类的某些拷贝控制成员，编译器将合成的成员定义为删除函数**。本质上，这些规则的含义是：若类有数据成员不可默认构造、拷贝、赋值、销毁，则该类对应的成员函数被定义为删除：**

- 删除合成析构函数：
  - 类某成员的析构函数是删除的或不可访问
- 删除合成拷贝构造函数：
  - 类某成员的拷贝构造函数是删除的或不可访问
  - 类某成员的析构函数是删除的或不可访问（可能创建无法销毁的对象）
- 删除合成拷贝赋值算符：
  - 类某成员的拷贝赋值算符是删除的或不可访问
  - 类有const成员或引用成员（可给引用成员赋值，但改变的是底层共享对象，不是期望结果）
- 删除默认构造函数：
  - 类某成员的析构函数是删除的或不可访问
  - 类的引用成员没有类内初始值
  - 类的const成员没有类内初始值且类型未显式定义默认构造函数

- C++11之前，阻止拷贝控制的方法是将拷贝构造函数和拷贝赋值算符`声明为private且不定义`

  - 声明为private，保证类外拷贝时在编译期报错
  - 声明但不定义，保证友元和成员函数拷贝时在链接期报错

- 例子：通过声明为`private`且不定义来阻止拷贝

  ```c++
  class PrivateCopy{
  public:
      PrivateCopy()=default;
      ~PrivateCopy();
  private:
      //将拷贝构造函数和拷贝赋值算符声明为private且不定义，阻止类被拷贝
      PrivateCopy(const PrivateCopy &);
      PrivateCopy &operator=(const PrivateCopy &);
  };
  ```

#### 习题尝试

+ 13.18

  ```c++
  
  ```

  

## 二.拷贝控制和资源管理

